# 架构可视化说明

## 核心架构图解

### 1. 数据流向图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           数据处理全流程                                        │
└─────────────────────────────────────────────────────────────────────────────┘

第一步：数据输入
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  PostgreSQL │    │    CSV文件   │    │   外部API   │
│   财务数据   │    │   价格数据   │    │   宏观数据   │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       └──────────────────┼──────────────────┘
                          │
                          ▼
第二步：数据分块
┌─────────────────────────────────────────────────────┐
│              数据分块器 (DataPartitioner)           │
│                                                     │
│ 按日期分块     按代码分块     按大小分块            │
│ [2023-01-01]   [000001.SZ]   [1000 rows]          │
│ [2023-01-02]   [000002.SZ]   [1000 rows]          │
│ [2023-01-03]   [600000.SH]   [1000 rows]          │
│     ...            ...          ...               │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
第三步：增量检测
┌─────────────────────────────────────────────────────┐
│              增量检测引擎                            │
│                                                     │
│ 对每个Block：                                       │
│ 1. 计算数据指纹 (SHA256)                            │
│ 2. 与缓存比较                                       │
│ 3. 标记处理状态                                     │
│                                                     │
│ ✓ 未变化 → 跳过处理                                 │
│ ✗ 已变化 → 加入处理队列                             │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
第四步：并行处理
┌─────────────────────────────────────────────────────┐
│                  计算图引擎                          │
│                                                     │
│   Block1 ──┐                     ┌── Result1       │
│   Block2 ──┼── [DataJoin处理器] ──┼── Result2       │
│   Block3 ──┘                     └── Result3       │
│                        │                           │
│                        ▼                           │
│   Result1 ──┐                     ┌── Final1       │
│   Result2 ──┼── [比率计算处理器] ──┼── Final2       │
│   Result3 ──┘                     └── Final3       │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
第五步：结果缓存
┌─────────────────────────────────────────────────────┐
│                  块存储系统                          │
│                                                     │
│ 内存缓存 (LRU)          磁盘存储 (Parquet)          │
│ ┌─────────────┐        ┌─────────────┐             │
│ │ 热点Block   │◄──────►│ 完整Block   │             │
│ │ 快速访问    │        │ 持久化存储  │             │
│ └─────────────┘        └─────────────┘             │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
第六步：结果合并
┌─────────────────────────────────────────────────────┐
│                结果聚合器                            │
│                                                     │
│ 1. 收集新处理的Block结果                             │
│ 2. 加载缓存的历史Block结果                           │
│ 3. 按业务逻辑合并数据                               │
│ 4. 输出完整的结果数据集                             │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
第七步：最终输出
┌─────────────────────────────────────────────────────┐
│                  业务结果                            │
│                                                     │
│ • 财务比率数据 (PE, PB, ROE, 等)                    │
│ • 技术指标数据 (MA, RSI, MACD, 等)                  │
│ • 风险指标数据 (波动率, 最大回撤, 等)                │
│ • 自定义分析结果                                     │
└─────────────────────────────────────────────────────┘
```

### 2. 类关系图

```
                    ┌──────────────────┐
                    │      Block       │
                    │ ──────────────── │
                    │ + block_id       │
                    │ + data           │
                    │ + data_hash      │
                    │ + metadata       │
                    └─────────┬────────┘
                              │
                              │ 管理
                              ▼
                    ┌──────────────────┐
                    │   BlockStore     │
                    │ ──────────────── │
                    │ + save_block()   │
                    │ + load_block()   │
                    │ + cache_block()  │
                    │ + get_hash()     │
                    └─────────┬────────┘
                              │
                              │ 使用
                              ▼
    ┌─────────────────────────────────────────────────────────┐
    │                  BlockProcessor                         │
    │ ─────────────────────────────────────────────────────── │
    │ + process_blocks()        # 处理多个Block               │
    │ + process_single_block()  # 处理单个Block               │
    │ + check_incremental()     # 增量检测                    │
    │ + merge_results()         # 结果合并                    │
    └─────────────────────┬───────────────────────────────────┘
                          │
                          │ 继承
                          ▼
    ┌─────────────────────────────────────────────────────────┐
    │                具体处理器类                              │
    ├─────────────────────────────────────────────────────────┤
    │ DataJoinProcessor      # 数据联接处理器                 │
    │ FinancialRatioProcessor # 财务比率计算处理器            │
    │ TechnicalProcessor     # 技术指标计算处理器             │
    │ RiskProcessor          # 风险指标计算处理器             │
    │ CustomProcessor        # 自定义处理器                   │
    └─────────────────────┬───────────────────────────────────┘
                          │
                          │ 管理
                          ▼
                ┌──────────────────┐
                │ ComputationGraph │
                │ ──────────────── │
                │ + add_processor()│
                │ + execute()      │
                │ + topological_sort() │
                │ + handle_dependencies() │
                └──────────────────┘
```

### 3. Block生命周期图

```
新数据到达
    │
    ▼
┌───────────┐
│ 数据分块   │ ── 根据策略将数据分割成Block
└─────┬─────┘
      │
      ▼
┌───────────┐
│ 指纹计算   │ ── 计算Block的SHA256哈希值
└─────┬─────┘
      │
      ▼
┌───────────┐    是    ┌───────────┐
│ 缓存检查   │ ────────► │ 跳过处理   │
│ 是否存在？ │          │ 使用缓存   │
└─────┬─────┘          └───────────┘
      │ 否
      ▼
┌───────────┐    否    ┌───────────┐
│ 指纹比较   │ ────────► │ 开始处理   │
│ 是否变化？ │          │ 新计算     │
└─────┬─────┘          └─────┬─────┘
      │ 是                   │
      ▼                      │
┌───────────┐                │
│ 开始处理   │◄───────────────┘
│ 重新计算   │
└─────┬─────┘
      │
      ▼
┌───────────┐
│ 结果缓存   │ ── 将处理结果保存到内存和磁盘
└─────┬─────┘
      │
      ▼
┌───────────┐
│ 结果返回   │ ── 返回处理结果供后续使用
└───────────┘
```

### 4. 并行处理示意图

```
时间轴 →
                Block1    Block2    Block3    Block4
                  │        │        │        │
CPU核心1:        ├────┤    ├────┤             
CPU核心2:                  ├────┤    ├────┤   
CPU核心3:        ├────┤             ├────┤   
CPU核心4:                           ├────┤    ├────┤

说明：
- 每个Block可以在不同CPU核心上并行处理
- 处理器之间通过依赖关系协调执行顺序
- 内存和I/O资源通过智能调度避免冲突
- 异常Block不影响其他Block的处理
```

### 5. 内存使用示意图

```
内存分配示意图：

┌─────────────────────────────────────────────────┐ ← 系统内存上限
│                                                 │
│  ┌─────────────────────────────────┐           │
│  │         应用程序内存             │           │
│  │                                 │           │
│  │  ┌─────────────────────────┐   │           │
│  │  │      Block缓存区        │   │ ← 可配置大小
│  │  │                         │   │
│  │  │ [Block1] [Block2]       │   │ ← LRU管理
│  │  │ [Block3] [Block4]       │   │
│  │  │    ...    ...           │   │
│  │  └─────────────────────────┘   │           │
│  │                                 │           │
│  │  ┌─────────────────────────┐   │           │
│  │  │     处理器工作区        │   │ ← 临时计算空间
│  │  └─────────────────────────┘   │           │
│  │                                 │           │
│  └─────────────────────────────────┘           │
│                                                 │
└─────────────────────────────────────────────────┘

内存管理策略：
1. LRU淘汰最久未使用的Block
2. 大Block优先写入磁盘
3. 处理完成立即释放临时内存
4. 定期垃圾回收
```

### 6. 计算图执行流程

```
依赖关系示例：

┌─────────────┐    ┌─────────────┐
│   财务数据   │    │   市值数据   │
│   Block     │    │   Block     │
└──────┬──────┘    └──────┬──────┘
       │                  │
       └────────┬─────────┘
                │
                ▼
       ┌─────────────────┐
       │  数据联接处理器  │
       │ DataJoinProcessor│
       └─────────┬───────┘
                 │
                 ▼
       ┌─────────────────┐
       │ 财务比率计算处理器│
       │ RatioProcessor  │
       └─────────┬───────┘
                 │
                 ▼
       ┌─────────────────┐
       │    最终结果     │
       └─────────────────┘

执行顺序：
1. 拓扑排序确定执行顺序
2. 并行执行无依赖的处理器
3. 按依赖关系串行执行有依赖的处理器
4. 错误隔离，单个失败不影响其他
```

### 7. 增量处理效果图

```
第一次运行（全量处理）：
时间: 0  ────────────────────────────── 100%
数据: [所有Block都需要处理]
耗时: 10分钟

第二次运行（增量处理）：
时间: 0  ─── 20%
数据: [只有20%的Block发生变化]
耗时: 2分钟
性能提升: 5倍

增量处理优势：
✓ 只处理变化的数据
✓ 充分利用缓存结果  
✓ 大幅减少计算时间
✓ 降低系统资源消耗
```

### 8. 技术栈架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        技术栈分层                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  业务层     │ 股票分析  │ 基金评估  │ 风险管理  │ 策略回测      │
│            └───────────┴───────────┴───────────┴──────────────┘
│                                 │                               │
│  处理层     │ DataJoin  │ RatioCalc │ TechIndicator │ Risk    │  │
│            └───────────┴───────────┴───────────────┴─────────┘  │
│                                 │                               │
│  引擎层     │ ComputationGraph │ BlockProcessor │ BlockStore │  │
│            └──────────────────┴────────────────┴─────────────┘  │
│                                 │                               │
│  加速层     │    Numba JIT     │   NumPy SIMD   │  AsyncIO   │  │
│            └──────────────────┴────────────────┴─────────────┘  │
│                                 │                               │
│  存储层     │   PostgreSQL     │     Parquet    │  Memory     │  │
│            └──────────────────┴────────────────┴─────────────┘  │
│                                 │                               │
│  系统层     │      Linux       │     Python     │   Docker    │  │
│            └──────────────────┴────────────────┴─────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

这些图表清晰地展示了：

1. **数据处理的完整流程**：从数据输入到最终输出的每个步骤
2. **类关系和继承结构**：各个组件之间的关系
3. **Block的生命周期**：数据块如何被创建、处理和缓存
4. **并行处理机制**：如何充分利用多核CPU
5. **内存管理策略**：如何高效使用内存资源
6. **计算图执行逻辑**：处理器之间的依赖关系和执行顺序
7. **增量处理优势**：性能提升的直观展示
8. **技术栈分层**：整个架构的技术组成

通过这些可视化图表，可以更好地理解这个基于Block的量化投资数据处理架构的设计思路和实现细节。 