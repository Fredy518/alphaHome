# 上下文
文件名：AI_Task_Calendar_20240516_103000.md
创建于：2024-05-16 10:30:00
创建者：AI
关联协议：RIPER-5 + Multidimensional + Agent Protocol 

# 任务描述
用户要求在 `alphahome/fetchers/tasks/others/tushare_others_calendar.py` 文件中创建一个新的 Tushare 任务，用于获取多个交易所（SSE, SZSE, CFFEX, SHFE, CZCE, DCE, INE, HKEX）的交易日历数据。该任务应参考 `alphahome/fetchers/tools/calendar.py` 的数据获取方法（特别是港股日历的分块逻辑）和 `alphahome/fetchers/tasks/fund/tushare_fund_basic.py` 的任务编码结构。

# 项目概述
alphaHome 项目，一个包含数据获取 (fetchers)、因子计算 (factors) 等模块的量化金融系统。

---
*以下部分由 AI 在协议执行过程中维护*
---

# --- 原始方案 (已迭代，见后续) ---
# 分析 (由 RESEARCH 模式填充)
# ... (原始内容存档或简述)

# 提议的解决方案 (由 INNOVATE 模式填充)
# ... (原始内容存档或简述)

# 实施计划 (由 PLAN 模式生成)
# ... (原始内容存档或简述)

# --- 方案迭代：根据新的日志和用户建议进行调整 (2024-05-20) ---

# 分析 (针对2024-05-20日志)
- **数据库索引创建错误**: `asyncpg.exceptions.UndefinedColumnError: 字段 "exchange, cal_date" 不存在`。原因是 `indexes` 定义中 `columns: "exchange, cal_date"` (单一字符串) 格式不正确，应为 `columns: ["exchange", "cal_date"]` (字段名列表/元组)。
- **Tushare API 调用错误**: `Msg: 请指定正确的接口名, Payload: {'api_name': 'calendar_dynamic', ...}`。这表明 `TushareTask` 基类在实际API调用时，使用了类属性 `self.api_name` (即占位符 `"calendar_dynamic"`)，而不是在 `fetch_data_for_batch` 方法中动态确定的真实API名称 (`trade_cal` 或 `hk_tradecal`)。这证实了 `api_name` 类属性对于 `TushareTask` 的核心执行流程至关重要。

# 提议的解决方案 (迭代后，采纳用户建议)
- **拆分任务**: 将原单一的 `TushareOthersCalendarTask` 拆分为两个独立的、更专注的任务类：
    1.  `TushareMainlandCalendarTask`: 负责获取所有中国大陆交易所 (SSE, SZSE, CFFEX, SHFE, CZCE, DCE, INE) 的交易日历。
    2.  `TushareHkCalendarTask`: 负责获取港股 (HKEX) 交易日历。
- **共享数据表**: 两个新任务将继续使用同一个目标数据表: `tushare_others_calendar`。
- **固定 API 名称**: 
    - `TushareMainlandCalendarTask` 将使用固定的 `api_name = "trade_cal"`。
    - `TushareHkCalendarTask` 将使用固定的 `api_name = "hk_tradecal"`。
- **特定逻辑封装**: 
    - `TushareHkCalendarTask` 将包含原有的港股日历日期分块获取逻辑。
    - `TushareMainlandCalendarTask` 的数据获取逻辑将更直接，无需分块。
- **修复索引定义**: 在两个新任务的类定义中，以及任何其他引用此表结构的地方，修正 `indexes` 属性中组合索引的 `columns` 定义，确保其使用正确的列表/元组格式，例如 `columns: ["exchange", "cal_date"]`。

# 实施计划 (新版)

**通用修改**:
1.  **备份与重命名/删除旧文件**: `alphahome/fetchers/tasks/others/tushare_others_calendar.py` 将被拆分逻辑取代，建议备份或重命名为 `tushare_others_calendar_old.py`。
2.  **创建新文件**:
    *   `alphahome/fetchers/tasks/others/tushare_mainland_calendar.py`
    *   `alphahome/fetchers/tasks/others/tushare_hk_calendar.py`

**A. `alphahome/fetchers/tasks/others/tushare_mainland_calendar.py` 实现 (`TushareMainlandCalendarTask`)**
3.  添加必要的导入: `pandas`, `datetime`, `timedelta`, `List`, `Dict`, `Any`, `Optional`, `TushareTask`, `task_register`.
4.  定义 `TushareMainlandCalendarTask(TushareTask)` 类并添加 `@task_register()`。
5.  定义核心属性:
    *   `name = "tushare_mainland_calendar"`
    *   `description = "获取A股及中国大陆期货交易所交易日历"`
    *   `table_name = "tushare_others_calendar"`
    *   `primary_keys = ["exchange", "cal_date"]`
    *   `date_column = "cal_date"`
    *   `default_start_date = "19900101"`
    *   `_EXCHANGES_TO_FETCH = ['SSE', 'SZSE', 'CFFEX', 'SHFE', 'CZCE', 'DCE', 'INE']`
6.  定义Tushare特定属性:
    *   `api_name = "trade_cal"`
    *   `fields = ['exchange', 'cal_date', 'is_open', 'pretrade_date']`
    *   `column_mapping = {}`
    *   `transformations = {"is_open": lambda x: pd.to_numeric(x, errors='coerce').astype('Int64')}`
7.  定义数据库 `schema`:
    ```python
    schema = {
        "exchange": {"type": "VARCHAR(10)", "constraints": "NOT NULL"},
        "cal_date": {"type": "DATE", "constraints": "NOT NULL"},
        "is_open": {"type": "INTEGER"},
        "pretrade_date": {"type": "DATE"},
        "update_time": {"type": "TIMESTAMP WITHOUT TIME ZONE", "default": "CURRENT_TIMESTAMP"}
    }
    ```
8.  定义数据库 `indexes` (修正 `columns` 格式):
    ```python
    indexes = [
        {"name": "idx_mainland_cal_exch_date", "columns": ["exchange", "cal_date"], "unique": True},
        {"name": "idx_mainland_cal_is_open", "columns": ["is_open"]},
        {"name": "idx_mainland_cal_pretrade", "columns": ["pretrade_date"]},
        {"name": "idx_mainland_cal_update", "columns": ["update_time"]}
    ]
    ```
9.  实现 `__init__` 方法 (标准).
10. 实现 `async def get_batch_list(self, start_date: str, end_date: str, **kwargs: Any) -> List[Dict]:` (循环 `_EXCHANGES_TO_FETCH`).
11. 实现 `async def fetch_data_for_batch(self, batch_params: Dict, start_date: str, end_date: str) -> pd.DataFrame:` (使用 `self.api_name`, `params` 中包含 `exchange`).
12. 实现 `async def process_data(self, df: pd.DataFrame, **kwargs: Any) -> pd.DataFrame:` (标准).
13. 实现 `async def validate_data(self, df: pd.DataFrame, **kwargs: Any) -> pd.DataFrame:` (标准).
14. 所有注释中文化。

**B. `alphahome/fetchers/tasks/others/tushare_hk_calendar.py` 实现 (`TushareHkCalendarTask`)**
15. 添加必要的导入: `pandas`, `datetime`, `timedelta`, `calendar as std_calendar`, `List`, `Dict`, `Any`, `Optional`, `TushareTask`, `task_register`.
16. 定义 `TushareHkCalendarTask(TushareTask)` 类并添加 `@task_register()`.
17. 定义核心属性:
    *   `name = "tushare_hk_calendar"`
    *   `description = "获取港股交易日历"`
    *   `table_name = "tushare_others_calendar"` (与大陆任务共享表)
    *   `primary_keys = ["exchange", "cal_date"]`
    *   `date_column = "cal_date"`
    *   `default_start_date = "19900101"`
    *   `_HKEX_CHUNK_YEARS = 2`
18. 定义Tushare特定属性:
    *   `api_name = "hk_tradecal"`
    *   `fields = ['exchange', 'cal_date', 'is_open', 'pretrade_date']`
    *   `column_mapping = {}` (假设 `hk_tradecal` 返回 `pretrade_date`)
    *   `transformations = {"is_open": lambda x: pd.to_numeric(x, errors='coerce').astype('Int64')}`
19. 定义数据库 `schema` (与 `TushareMainlandCalendarTask` 完全一致).
20. 定义数据库 `indexes` (与 `TushareMainlandCalendarTask` 完全一致, 确保 `columns` 格式正确, 索引名可区分，如 `idx_hk_cal_...`):
    ```python
    indexes = [
        {"name": "idx_hk_cal_exch_date", "columns": ["exchange", "cal_date"], "unique": True},
        {"name": "idx_hk_cal_is_open", "columns": ["is_open"]},
        {"name": "idx_hk_cal_pretrade", "columns": ["pretrade_date"]},
        {"name": "idx_hk_cal_update", "columns": ["update_time"]}
    ]
    ```
    *注：由于两个任务写入同一个表，索引实际上是在表级别定义的。因此，`indexes` 定义应该在两个任务中保持一致（指向相同的索引名和结构），或者由基类/数据库管理器统一处理。为简单起见，此处定义为相同结构但不同名，实际执行时应确保只创建一套索引。更好的做法是，如果基类`TushareTask`的表创建逻辑能处理重复的索引定义（例如，使用 `CREATE INDEX IF NOT EXISTS`），那么保持一致的索引名是可行的。这里为了清晰，暂时用不同名，但指出它们作用于同一张表。* **修正：索引名应该保持一致，因为它们作用于同一个表。数据库管理器应能处理 `IF NOT EXISTS`。** 将统一索引名为 `idx_shared_cal_...`。
    ```python
    indexes = [
        {"name": "idx_shared_cal_exch_date", "columns": ["exchange", "cal_date"], "unique": True},
        {"name": "idx_shared_cal_is_open", "columns": ["is_open"]},
        {"name": "idx_shared_cal_pretrade", "columns": ["pretrade_date"]},
        {"name": "idx_shared_cal_update", "columns": ["update_time"]}
    ]
    ```
21. 实现 `__init__` 方法 (标准).
22. 实现 `async def get_batch_list(self, start_date: str, end_date: str, **kwargs: Any) -> List[Dict]:` (返回 `[{'exchange_code': 'HKEX'}]`).
23. 实现 `async def fetch_data_for_batch(self, batch_params: Dict, start_date: str, end_date: str) -> pd.DataFrame:` (包含日期分块逻辑，添加 `exchange='HKEX'` 列).
24. 实现 `async def process_data(self, df: pd.DataFrame, **kwargs: Any) -> pd.DataFrame:` (标准).
25. 实现 `async def validate_data(self, df: pd.DataFrame, **kwargs: Any) -> pd.DataFrame:` (标准).
26. 所有注释中文化。

**C. 更新 `alphahome/fetchers/tasks/others/__init__.py` (如果需要)**
27. 确保新任务能被任务工厂发现 (通常 `@task_register` 会处理)。

**D. 任务文件更新**
28. 在本文档 (AI_Task_Calendar_20240516_103000.md) 中记录新的计划和后续执行。

# 当前执行步骤 (由 EXECUTE 模式在开始执行某步骤时更新)
> 正在执行: "所有计划内步骤已完成。"

# 任务进度 (由 EXECUTE 模式在每步完成后追加)
*   [实际修改日期时间]
    *   步骤：检查清单第 [32] 项: 修改 `tushare_others_hktradecal.py` 中的类名和相关内容。
    *   修改：`alphahome/fetchers/tasks/others/tushare_others_hktradecal.py`
    *   更改摘要：类名更新为 `TushareOthersHktradecalTask`，任务 `name` 和 `description` 属性已更新，相关日志和注释已调整。
    *   原因：用户请求。
    *   阻碍：无。
    *   用户确认状态：[AI操作]
*   [实际修改日期时间]
    *   步骤：检查清单第 [33] 项: 更新 `alphahome/fetchers/tasks/others/__init__.py`。
    *   修改：`alphahome/fetchers/tasks/others/__init__.py`
    *   更改摘要：更新了导入语句和 `__all__` 列表以反映新的文件名和类名。
    *   原因：用户请求的任务命名规范化。
    *   阻碍：无。
    *   用户确认状态：[AI操作，待后续整体确认] 